(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{551:function(t,s,a){"use strict";a.r(s);var e=a(4),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"第8章-字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第8章-字符串"}},[t._v("#")]),t._v(" 第8章 字符串")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#unicode"}},[t._v("Unicode")])]),a("li",[a("a",{attrs:{href:"#字符串和结合"}},[t._v("字符串和结合")])]),a("li",[a("a",{attrs:{href:"#子字符串"}},[t._v("子字符串")])]),a("li",[a("a",{attrs:{href:"#编码单元视图"}},[t._v("编码单元视图")])]),a("li",[a("a",{attrs:{href:"#字符范围"}},[t._v("字符范围")])]),a("li",[a("a",{attrs:{href:"#characterset"}},[t._v("CharacterSet")])]),a("li",[a("a",{attrs:{href:"#字面量"}},[t._v("字面量")])]),a("li",[a("a",{attrs:{href:"#customstringconvertible-和-customdebugstringconvertible"}},[t._v("CustomStringConvertible 和 CustomDebugStringConvertible")])]),a("li",[a("a",{attrs:{href:"#文本输出流"}},[t._v("文本输出流")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"unicode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unicode"}},[t._v("#")]),t._v(" Unicode")]),t._v(" "),a("p",[a("strong",[t._v("编码单元 (code unit)")]),t._v(" 组成 "),a("strong",[t._v("Unicode标量 (Unicode scalar)")]),t._v("；Unicode标量 (Unicode scalar) 组成"),a("strong",[t._v("字符 (Character)")]),t._v("。")]),t._v(" "),a("p",[t._v("Unicode 中的"),a("strong",[t._v("编码点 (code point)")]),t._v(" 介于 0~0x10FFFF 的一个值。")]),t._v(" "),a("p",[t._v('Unicode 标量 (Unicode scalar) 等价于 Unicode 编码点 (code point)，除了 0xD800–0xDFFF 之间的“代理” (surrogate) 编码点。Unicode 标量 (Unicode scalar) 在 Swift 中以 "'),a("strong",[t._v("\\u{xxxx}")]),t._v('" 来表示。Unicode 标量 (Unicode scalar) 在 Swift 中对应的类型是 '),a("strong",[t._v("Unicode.Scalar")]),t._v("，它是一个对 UInt32 的封装类型。")]),t._v(" "),a("p",[t._v("Unicode 编码点 (code point) 可以编码成许多不同宽度的编码单元 (code unit)，最普通的是使用 UTF-8 或者 UTF-16")]),t._v(" "),a("p",[t._v("用户在屏幕上看到的单个字符可能有多个编码点组成的，在 Unicode 中，这种从用户视角看到的字符，叫做"),a("strong",[t._v("扩展字符族 (extended grapheme cluster)")]),t._v("，在 Swift 中，字符族用 "),a("strong",[t._v("Character")]),t._v(" 类型来表示。")]),t._v(" "),a("p",[t._v("Swift 5 内部使用了 "),a("strong",[t._v("UTF-8")]),t._v(" 作为非ASCII字符串的编码方式。"),a("a",{attrs:{href:"https://swift.org/blog/utf8-string/",target:"_blank",rel:"noopener noreferrer"}},[t._v("UTF-8 String"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("é (U+00E9) 与 é (U+0065) + (U+0301) 在 Swift 是表示相同的字符，Unicode 规范将此称作"),a("strong",[t._v("标准等价")]),t._v("。")]),t._v(" "),a("p",[t._v("一些颜文字有不可见的"),a("strong",[t._v("零宽度连接符 (zero-width joiner, ZWJ) (U+200D)")]),t._v(" 所连接组合。比如")]),t._v(" "),a("p",[t._v("👨‍👩‍👧‍👦 = 👨+ZWJ+👩+ZWJ+👧+ZWJ+👦 组成")]),t._v(" "),a("div",{staticClass:"language-swift line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 查看String的Unicode标量组成")]),t._v("\nstring"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("unicodeScalars"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("map")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"U+'),a("span",{pre:!0,attrs:{class:"token interpolation"}},[a("span",{pre:!0,attrs:{class:"token delimiter variable"}},[t._v("\\(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("$"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" radix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" uppercase"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token delimiter variable"}},[t._v(")")])]),t._v('"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[a("strong",[t._v("StringTransform")]),t._v(": Constants representing an ICU string transform.")]),t._v(" "),a("h2",{attrs:{id:"字符串和结合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串和结合"}},[t._v("#")]),t._v(" 字符串和结合")]),t._v(" "),a("p",[t._v("String 是双向索引 (BidirectionalCollection) 而非随机访问 (RandomAccessCollection)")]),t._v(" "),a("p",[t._v("String 还满足 (RangeReplaceableCollection)")]),t._v(" "),a("h2",{attrs:{id:"子字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子字符串"}},[t._v("#")]),t._v(" 子字符串")]),t._v(" "),a("p",[t._v("和所有集合类型一样，String 有一个特定的 SubSequence 类型，它就是 Substring。 Substring 和 ArraySlice 很相似：它是一个以不同起始和结束索引的对原字符串的切片。子字符串和原字符串共享文本存储，这带来的巨大的好处，它让对字符串切片成为了非常高效的操作。")]),t._v(" "),a("p",[t._v("Substring 和 String 的接口几乎完全一样。这是通过一个叫做 "),a("em",[t._v("StringProtocol")]),t._v(" 的通用协议来达到的，String 和 Substring 都遵守这个协议。因为几乎所有的字符串 API 都被定义在 "),a("em",[t._v("StringProtocol")]),t._v(" 上，对于 Substring，你完全可以假装将它看作就是一个 String，并完成各项操作。")]),t._v(" "),a("p",[t._v("和所有的切片一样，子字符串也只能用于短期的存储，这可以避免在操作过程中发生昂贵的复制。当这个操作结束，你想将结果保存起来，或是传递给下一个子系统，你应该通过初始化方法从 Substring 创建一个新的String。")]),t._v(" "),a("p",[t._v("不鼓励⻓期存储子字符串的根本原因在于，子字符串会一直持有整个原始字符串。")]),t._v(" "),a("p",[t._v("不建议将 API 从接受 String 实例转换为 "),a("em",[t._v("StringProtocol")])]),t._v(" "),a("h2",{attrs:{id:"编码单元视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编码单元视图"}},[t._v("#")]),t._v(" 编码单元视图")]),t._v(" "),a("p",[t._v("String 提供 3 种视图：unicodeScalars, utf16和utf8")]),t._v(" "),a("p",[t._v("如果你需要一个以 null 结尾的表示的话，可以使用 String 的 "),a("code",[t._v("withCString")]),t._v(" 方法或者 "),a("code",[t._v("utf8CString")]),t._v(" 属性。后一种会返回一个字节的数组")]),t._v(" "),a("h2",{attrs:{id:"字符范围"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符范围"}},[t._v("#")]),t._v(" 字符范围")]),t._v(" "),a("p",[t._v("Character 并没有实现 "),a("em",[t._v("Strideable")]),t._v(" 协议，因此不是可数的范围")]),t._v(" "),a("h2",{attrs:{id:"characterset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#characterset"}},[t._v("#")]),t._v(" CharacterSet")]),t._v(" "),a("p",[t._v("CharacterSet 实际上应该被叫做 UnicodeScalarSet，因为它确实就是一个表示一系列 Unicode 标量的数据结构体。")]),t._v(" "),a("h2",{attrs:{id:"字面量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字面量"}},[t._v("#")]),t._v(" 字面量")]),t._v(" "),a("p",[t._v("字符串字面量隶属于 "),a("em",[t._v("ExpressibleByStringLiteral")]),t._v("、 "),a("em",[t._v("ExpressibleByExtendedGraphemeClusterLiteral")]),t._v(" 和 "),a("em",[t._v("ExpressibleByUnicodeScalarLiteral")]),t._v(" 这三个层次结构的协议，所以实现起来比数组字面量稍费劲一些。这三个协议都定义了支持各自字面量类型的 "),a("code",[t._v("init")]),t._v(" 方法，你必须对这三个都进行实现。不过除非你真的需要区分是从一个 Unicode 标量还是从一个字位簇来创建实例这样细粒度的逻辑，否则只需要实现字符串版本就行了。")]),t._v(" "),a("h2",{attrs:{id:"customstringconvertible-和-customdebugstringconvertible"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#customstringconvertible-和-customdebugstringconvertible"}},[t._v("#")]),t._v(" CustomStringConvertible 和 CustomDebugStringConvertible")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("CustomStringConvertible")]),t._v(" "),a("th",[t._v("CustomDebugStringConvertible")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("var description: String")]),t._v(" "),a("td",[t._v("var debugDescription: String")])]),t._v(" "),a("tr",[a("td",[t._v("String(describing:)")]),t._v(" "),a("td",[t._v("String(reflecting:)")])]),t._v(" "),a("tr",[a("td",[t._v("print函数")]),t._v(" "),a("td",[t._v("debugPrint函数")])])])]),t._v(" "),a("h2",{attrs:{id:"文本输出流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文本输出流"}},[t._v("#")]),t._v(" 文本输出流")]),t._v(" "),a("p",[a("code",[t._v("print(_:to:)")]),t._v(" 和 "),a("code",[t._v("dump(_:to:)")]),t._v("。"),a("code",[t._v("to")]),t._v(" 参数就是输出的目标，它可以是任何实现了 "),a("em",[t._v("TextOutputStream")]),t._v(" 协议的类型")]),t._v(" "),a("div",{staticClass:"language-swift line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protocol")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("TextOutputStream")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mutating")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("_")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("输出流可以是实现了 "),a("em",[t._v("TextOutputStreamable")]),t._v(" 协议的任意类型")]),t._v(" "),a("div",{staticClass:"language-swift line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-swift"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protocol")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("TextOutputStreamable")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" write"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Target")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("to target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inout")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Target")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Target")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("TextOutputStream")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])])])}),[],!1,null,null,null);s.default=r.exports}}]);