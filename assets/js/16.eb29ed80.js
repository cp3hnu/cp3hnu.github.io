(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{433:function(t,a,r){t.exports=r.p+"assets/img/402-1.25d5288d.png"},434:function(t,a,r){t.exports=r.p+"assets/img/402-2.f73b6ac0.png"},435:function(t,a,r){t.exports=r.p+"assets/img/402-3.c14b764a.png"},436:function(t,a,r){t.exports=r.p+"assets/img/402-4.9b6f12ab.png"},437:function(t,a,r){t.exports=r.p+"assets/img/402-5.c5e02e2f.png"},438:function(t,a,r){t.exports=r.p+"assets/img/402-6.75d10d77.png"},439:function(t,a,r){t.exports=r.p+"assets/img/402-7.fe9200b9.png"},576:function(t,a,r){"use strict";r.r(a);var e=r(4),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_402-what-s-new-in-swift"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_402-what-s-new-in-swift"}},[t._v("#")]),t._v(" 402-What's New in Swift")]),t._v(" "),e("h2",{attrs:{id:"overview"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" Overview")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"#shared-swift-runtime-for-apps"}},[t._v("Shared Swift Runtime for Apps")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#binary-frameworks"}},[t._v("Binary Frameworks")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#library-evolution"}},[t._v("Library Evolution")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#shared-swift-runtime-for-apps"}},[t._v("Shared Swift Runtime for Apps")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#utf-8-string"}},[t._v("UTF-8 String")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#swift-tooling-and-open-source"}},[t._v("Swift Tooling and Open Source")])]),t._v(" "),e("li",[e("a",{attrs:{href:"#language-and-standard-library"}},[t._v("Language and Standard Library")])])]),t._v(" "),e("h2",{attrs:{id:"binary-frameworks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#binary-frameworks"}},[t._v("#")]),t._v(" Binary Frameworks")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://swift.org/blog/abi-stability-and-more/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ABI Stability and More"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://onevcat.com/2019/02/swift-abi/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Swift ABI 稳定对我们到底意味着什么"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://swift.org/blog/abi-stability-and-apple/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Evolving Swift On Apple Platforms After ABI Stability"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("Module + ABI stability\n= Binary frameworks")]),t._v(" "),e("p",[t._v("详情请看 "),e("RouterLink",{attrs:{to:"/notebook/wwdc/2019/documents/416-Binary Frameworks in Swift.html"}},[t._v("Binary Frameworks in Swift")])],1),t._v(" "),e("h3",{attrs:{id:"什么是-abi-stability"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-abi-stability"}},[t._v("#")]),t._v(" 什么是 ABI Stability")]),t._v(" "),e("p",[t._v("ABI = “Application Binary Interface”")]),t._v(" "),e("p",[t._v("Specifies details of a program’s representation at runtime")]),t._v(" "),e("p",[t._v("Compatible ABIs allows separately compiled code to interact at runtime")]),t._v(" "),e("p",[t._v("ABI 决定了编译后的代码在运行时如何交互，比如像函数调用这样的细节。")]),t._v(" "),e("p",[t._v("它到底是怎么工作的？参数中的值如何从调用方传递到被调用方？可用的元数据是什么？它在内存中是如何布局的？所有这些细节都是编译后的代码进行交互所必需的。")]),t._v(" "),e("p",[t._v("Exec 使用来自 Framework 的 API，它们必须能够在运行时相互通信。为了让这个工作，他们必须有一个兼容的 ABI。Exec 和 Framework 是独立编译的，但编译后的代码需要协同工作。在 ABI 稳定性之前，我们唯一的保证是，如果使用同一个编译器构建这些 ABI，它们将具有兼容的 ABI。所以 ABI Stability 以前，编译的 App Bundle 里面有 Swift runtime。")]),t._v(" "),e("p",[t._v("在 Swift 5 中，我们已经明确了这些细节，Swift 5 现在具有 ABI 稳定性，这意味着 App 和 Framework 不再需要用同一个编译器构建，只要它们是用 Swift 5 编译器或更高版本构建的就可以了。Swift runtime 已经存在 iOS 、macOS、tvOS 以及 watchOS 系统里了。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(433),alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:r(434),alt:""}})]),t._v(" "),e("h3",{attrs:{id:"abi-stability-带来的好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#abi-stability-带来的好处"}},[t._v("#")]),t._v(" ABI Stability 带来的好处")]),t._v(" "),e("ol",[e("li",[t._v("App Size 减少。对于 iOS 12.2 的系统，因为它们预装了 Swift 5 的 runtime，所以不再需要 Swift 的库，它们会被从 app bundle 中删掉。")]),t._v(" "),e("li",[t._v("因为系统集成了 Swift，所以大家都用同一个 Swift 了，App 启动的时候也就不需要额外加载 Swift，所以在新系统上会更快更省内存。")]),t._v(" "),e("li",[t._v("对于 Apple 的工程师来说，他们终于能在系统的框架里使用 Swift 了。这样一来，很多东西就不必通过 Objective-C wrap 一遍，这会让代码运行效率提高很多。")])]),t._v(" "),e("h3",{attrs:{id:"abi-stability-带来的坏处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#abi-stability-带来的坏处"}},[t._v("#")]),t._v(" ABI Stability 带来的坏处")]),t._v(" "),e("p",[t._v("在 ABI 稳定之前，Swift runtime 是作为开发工具的一部分，被作为库打包到 app 中的。这样一来，在开发时，我们可以随意使用新版本 Swift 的类型或特性，因为它们的版本是开发者自己决定的。不过，当 ABI 稳定后，Swift runtime 变为了用户系统的一部分，它从开发工具，变为了运行的环境，不再由我们开发者唯一决定。比如说，对应 iOS 13 的 Swift 5.1 的标准库中添加了某个类型 "),e("code",[t._v("A")]),t._v("，但是在 iOS 12.2 这个只搭载了 Swift 5 的系统中，并没有这个类型。这意味着我们需要在使用 Swift 的时候考虑设备兼容的问题：如果你需要兼容那些搭载了旧版本 Swift 的系统，那你将无法在代码里使用新版本的 Swift runtime 特性。")]),t._v(" "),e("p",[t._v("这和我们一直以来适配新系统的 API 时候的情况差不多，在 Swift 5 以后，我们需要等到 deploy target 升级到对应的版本，才能开始使用对应的 Swift 特性。这意味着，我们可能会需要写一些这样的兼容代码：")]),t._v(" "),e("div",{staticClass:"language-swift line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-swift"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" #"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("available")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("iOS "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("13.0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Swift 5.1 标准库中存在 A")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("A")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不存在 A 时的处理")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br")])]),e("p",[t._v('对于"新添加的某个类型"这种程度的兼容，我们可以用上面的方式处理。但是对于更靠近语言层面的一些东西 (比如现在已有的 '),e("code",[t._v("Codable")]),t._v(" 这样的特性)，恐怕适配起来就没有那么简单了。在未来，Deployment target 可能会和 Swift 语言版本挂钩，新的语言特性出现后，我们可能需要等待一段时间才能实际用上。而除了那些纯编译期间的内容外，任何与 Swift runtime 有关的特性，都会要遵守这个规则。")]),t._v(" "),e("h3",{attrs:{id:"什么是-module-stability"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-module-stability"}},[t._v("#")]),t._v(" 什么是 Module Stability")]),t._v(" "),e("p",[t._v("Swift libraries and the APIs they export are known as “modules”")]),t._v(" "),e("p",[t._v("ABI Stability 是关于在运行时混合不同的 Swift 版本。Module Stability 是关于编译时，主要是针对App使用的第三方库。以前用 Carthage 管理第三方库，当升级 Xcode 时，重新编译 App 的时候，经常提示第三库不是用当前编译器编译的，Module Stability 就是用来解决这个问题的。")]),t._v(" "),e("p",[t._v("以前，如果使用一个 Framework提供的 API，则这些 API 称为模块，是共享命名空间的一部分。当 Swift 编译器构建该 Framework 时，它会生成该 Framework 中所有 API 的清单(manifest)，这个清单被称为 Swift module file。Swift module file与当前的 Swift 编译器绑定，这意味着如果 Framework 是用不同版本的 Swift 编译器构建的，应用程序开发人员就无法导入这个Framework。也就是说，应用程序开发人员和库作者必须使用相同版本的编译器。")]),t._v(" "),e("p",[t._v("在 Swift 5.1中，我们引入了一个新的补充清单，它被称为 Swift module interface file，它更像是一个源文件。框架可以使用它来提供一个稳定的接口。现在 App 和 Framework 可以用不同的编译器进行编译。\n"),e("img",{attrs:{src:r(435),alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:r(436),alt:""}})]),t._v(" "),e("h2",{attrs:{id:"library-evolution"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#library-evolution"}},[t._v("#")]),t._v(" Library Evolution")]),t._v(" "),e("p",[t._v("现在，当 Swift Library 发生变化时，任何使用该 Library 的 App 必须重新编译。优点：因为编译器知道应用程序正在使用的 Library 的确切版本，所以它可以做出额外的假设，从而减少代码大小并使 App 运行得更快。但这些假设在 Library 的下一个版本的中可能不成立。")]),t._v(" "),e("p",[t._v("Library Evolution：发布 Library 新版本时，不需要重新编译 App。")]),t._v(" "),e("p",[t._v("Swift 已经实现了对 Library Evolution 的支持，非正式地称为"),e("strong",[t._v("弹性(resilience)")]),t._v("。对于需要它的 Library 来说，这是一个可选的特性，它使用还没有定稿的标注在性能和未来灵活性之间取得平衡。这在标准库的源代码中可以看到。在 Swift 4.2（"),e("a",{attrs:{href:"https://github.com/apple/swift-evolution/blob/master/proposals/0193-cross-module-inlining-and-specialization.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("SE-0193"),e("OutboundLink")],1),t._v("）中添加了@inlineable，这是第一个 Swift Evolution 过程，期待将来更多关于 Swift Evolution 的提议。")]),t._v(" "),e("h2",{attrs:{id:"shared-swift-runtime-for-apps"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shared-swift-runtime-for-apps"}},[t._v("#")]),t._v(" Shared Swift Runtime for Apps")]),t._v(" "),e("p",[t._v("In the OS")]),t._v(" "),e("ul",[e("li",[t._v("iOS 12.2")]),t._v(" "),e("li",[t._v("macOS 10.14.4")]),t._v(" "),e("li",[t._v("tvOS 12.2")]),t._v(" "),e("li",[t._v("watchOS 5.2")])]),t._v(" "),e("p",[t._v("iOS 12.2 及以上的系统使用 iOS 系统里的 Swift Runtime，iOS 12.2 以下的系统使用App Bundle里的 Swift Runtime。")]),t._v(" "),e("p",[t._v("从 App Store 下载 App 时，如果 target 运行的是 iOS 12.2 及以上的系统，则thins out runtime copy。")]),t._v(" "),e("h3",{attrs:{id:"疑问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#疑问"}},[t._v("#")]),t._v(" 疑问")]),t._v(" "),e("p",[t._v("Swift 5.1 的新特性能正常运行在 iOS 12.2（Swift 5 Runtime）上吗？")]),t._v(" "),e("p",[t._v("答：有的可以，有的不可以")]),t._v(" "),e("p",[t._v("比如 "),e("strong",[t._v("Opaque return types")]),t._v(" 这个新特性就不行，必须运行在iOS 13上，而 "),e("strong",[t._v("Property Wrappers")]),t._v("  和 "),e("strong",[t._v("Implicit returns from single-expression functions")]),t._v(" 这个新特性就可以。如果不能运行 Xcode 编译时会提示。")]),t._v(" "),e("h2",{attrs:{id:"utf-8-string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#utf-8-string"}},[t._v("#")]),t._v(" UTF-8 String")]),t._v(" "),e("p",[t._v("出于性能考虑，Swift 5 将 string 的编码方式由 UTF-16 转化为UTF-8， "),e("a",{attrs:{href:"https://swift.org/blog/utf8-string/",target:"_blank",rel:"noopener noreferrer"}},[t._v("UTF-8 String"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:r(437),alt:""}})]),t._v(" "),e("p",[t._v("String 结构变化\n"),e("img",{attrs:{src:r(438),alt:""}})]),t._v(" "),e("h2",{attrs:{id:"swift-tooling-and-open-source"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#swift-tooling-and-open-source"}},[t._v("#")]),t._v(" Swift Tooling and Open Source")]),t._v(" "),e("h3",{attrs:{id:"swiftnio"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#swiftnio"}},[t._v("#")]),t._v(" SwiftNIO")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/apple/swift-nio",target:"_blank",rel:"noopener noreferrer"}},[t._v("SwiftNIO"),e("OutboundLink")],1),t._v(" is a cross-platform asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients.")]),t._v(" "),e("h4",{attrs:{id:"sourcekit-lsp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sourcekit-lsp"}},[t._v("#")]),t._v(" SourceKit-LSP")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/apple/sourcekit-lsp",target:"_blank",rel:"noopener noreferrer"}},[t._v("SourceKit-LSP"),e("OutboundLink")],1),t._v(": Language Server Protocol implementation for Swift and C-based languages.  The SourceKit-LSP defines the protocol used between the editor or IDE and a language server that provides language features like autocomplete, jump to definition, or find our references. Using SourceKit-LSP, IDEs are editors which support the language server protocol, get these features for Swift packages.\n"),e("img",{attrs:{src:r(439),alt:""}})]),t._v(" "),e("h2",{attrs:{id:"language-and-standard-library"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#language-and-standard-library"}},[t._v("#")]),t._v(" Language and Standard Library")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/cp3hnu/What-s-New-in-Swift",target:"_blank",rel:"noopener noreferrer"}},[t._v("What‘s New in Swift"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=i.exports}}]);